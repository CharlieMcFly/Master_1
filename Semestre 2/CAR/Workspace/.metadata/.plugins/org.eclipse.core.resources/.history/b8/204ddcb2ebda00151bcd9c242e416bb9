package Serveur;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

import Client.Client;
import Exceptions.FTPConnexionException;
import Exceptions.FTPDisconnexionException;

public class FtpRequest extends Thread{
	
	private Socket socket;
	private String pathname;
	private BufferedReader reader;
	private PrintWriter writer;
	private String racine;
	private List<Client> clients;
	private Client client;
	
	/* Pour le transfert de données */
	private ServerSocket passiveServer;
	private DataInputStream dataReader;
	private DataOutputStream dataWriter;
	private Socket dataSocket;
	private String adress;
	private int port;
	private boolean passive;
	
	public void initClients(){
		clients = new ArrayList<Client>();
		Client c = new Client("Charlie", "123");
		c.setConnected(false);
		c.getDroit().setRead(true);
		c.getDroit().setWrite(true);
		clients.add(c);
	}
	
	public FtpRequest(Socket socket) {
		this.initClients();
		this.socket = socket;
		this.pathname = System.getProperty("user.dir");
		this.setRacine(this.pathname);
		try {
			this.reader = new BufferedReader(new InputStreamReader(
					this.socket.getInputStream()));
			this.writer = new PrintWriter(new OutputStreamWriter(
					this.socket.getOutputStream()), true);
			this.writer.println(220 + " Service ready, plz login");
		} catch (IOException e) {
			new FTPConnexionException();
		}
	}
	
	@Override
	public void run() {
		
		this.process();
		try {
			System.out.println("Closing connection");
			this.socket.close();
		} catch (IOException e) {
			new FTPDisconnexionException();
		}
	}
	
	/**
	 * Utilise la bonne strategie en fonction de la commande rentrée.
	 */
	public void process(){
		String line;
		try {
			while ((line = reader.readLine()) != null) {
				String request[] = line.split("\\s");
				Class classARetrouver;
				try {
					/**
					 * Pattern Factory
					 * Recupère la class en fonction de ce qui est entrée par le client
					 */
					classARetrouver = Class.forName("Strategy.Request"+request[0].toUpperCase());
					Object classRetrouver = classARetrouver.newInstance();
					Method m = classARetrouver.getMethod("doRequest", FtpRequest.class, request.getClass());
					m.invoke(classRetrouver, this, request);
					
				} catch (ClassNotFoundException e) {
					writer.println("La requête n'existe pas");
				} catch (NoSuchMethodException e) {
					writer.println("La méthode n'existe pas");
				} catch (SecurityException e) {
					writer.println("Problème de sécurité : Sécurity Exception");
				} catch (IllegalArgumentException e) {
					writer.println("Les arguments ne sont pas correctes");
				} catch (InvocationTargetException e) {
					
				}
			}
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/* Envoie un message */
	public void sendMessage(String message){
		this.getWriter().println(message);
	}
	
	/* SOCKET */
	public Socket getSocket() {
		return socket;
	}

	public void setSocket(Socket socket) {
		this.socket = socket;
	}
	
	/* SOCKET  DE DONNEES */
	public Socket getDataSocket() {
		return this.dataSocket;
	}

	public void setDataSocket(Socket dataSocket) {
		this.dataSocket = dataSocket;
	}

	/* PATHNAME */
	public String getPathname() {
		return pathname;
	}

	public void setPathname(String pathname) {
		this.pathname = pathname;
	}

	/* READER */
	public BufferedReader getReader() {
		return reader;
	}

	public void setReader(BufferedReader reader) {
		this.reader = reader;
	}

	/* PRINTER */
	public PrintWriter getWriter() {
		return writer;
	}

	public void setWriter(PrintWriter writer) {
		this.writer = writer;
	}

	/* RACINE */
	public String getRacine() {
		return racine;
	}

	public void setRacine(String racine) {
		this.racine = racine;
	}

	/* Client */
	public void setClient(Client clientConnecté) {
		this.client = clientConnecté;
	}

	public Client getClient() {
		return this.client;
	}
	
	/**
	 * Permet de vérifier si le client est dans la liste du serveur.
	 * 
	 * @param username
	 * @return true si l'username est dans la liste des clients
	 */
	public boolean contientClientUsername(String username) {
		for (Client u : this.clients) {
			if (u.isLogin(username))
				return true;
		}
		return false;
	}

	/**
	 * Retourne le client avec l'username passé en parametre
	 * 
	 * @param userName
	 * @return le client
	 */
	public Client getClientByUsername(String userName) {
		for (Client u : this.clients) {
			if (u.isLogin(userName))
				return u;
		}
		return null;
	}

	

	public void setPassive(boolean b) {
		this.passive = b;
		
	}
	
	public boolean getPassive() {
		return this.passive;
		
	}

	public void setPassiveServer(ServerSocket serverSocket) {
		this.passiveServer = serverSocket;
		
	}
	
	public ServerSocket getPassiveServer() {
		return this.passiveServer;
		
	}
	
	public DataInputStream getDataReader() {
		return this.dataReader;
	}

	public void setDataReader(DataInputStream dataReader) {
		this.dataReader = dataReader;
	}

	public DataOutputStream getDataWriter() {
		return this.dataWriter;
	}

	public void setDataWriter(DataOutputStream dataWriter) {
		this.dataWriter = dataWriter;
	}
	
	public String getAdress() {
		return this.adress;
	}

	public void setAdress(String adress) {
		this.adress = adress;
	}

	public int getPort() {
		return this.port;
	}

	public void setPort(int port) {
		this.port = port;
	}

}
